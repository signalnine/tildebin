#!/usr/bin/env python3
"""
Scan CPU hardware vulnerabilities and kernel mitigation status.

This script checks for CPU security vulnerabilities (Spectre, Meltdown, and
variants) and verifies kernel mitigations are enabled. Critical for security
compliance in large-scale baremetal deployments.

The script reads from:
- /sys/devices/system/cpu/vulnerabilities/ for kernel mitigation status
- /proc/cpuinfo for CPU model and flags
- /proc/cmdline for kernel parameters affecting mitigations

Useful for:
- Security compliance auditing across server fleets
- Identifying systems with disabled or missing mitigations
- Detecting CPU models vulnerable to specific attacks
- Verifying microcode updates are applied
- Fleet-wide vulnerability assessment

Exit codes:
    0 - All mitigations active, no vulnerabilities exposed
    1 - Vulnerabilities detected or mitigations not fully enabled
    2 - Usage error or required files not available
"""

import argparse
import sys
import json
import os
import re


# Known CPU vulnerabilities tracked by Linux kernel
KNOWN_VULNERABILITIES = [
    'spectre_v1',
    'spectre_v2',
    'meltdown',
    'spec_store_bypass',
    'l1tf',
    'mds',
    'tsx_async_abort',
    'itlb_multihit',
    'srbds',
    'mmio_stale_data',
    'retbleed',
    'gds',
    'spec_rstack_overflow',
]

# Status strings indicating vulnerability is mitigated
MITIGATED_PATTERNS = [
    'Mitigation:',
    'Not affected',
    'KVM: Mitigation:',
]

# Status strings indicating vulnerability is NOT mitigated
VULNERABLE_PATTERNS = [
    'Vulnerable',
    'Vulnerable:',
]


def get_cpu_info():
    """Get CPU model and flags from /proc/cpuinfo.

    Returns:
        dict: CPU information including model, vendor, flags
    """
    cpu_info = {
        'vendor': 'Unknown',
        'model_name': 'Unknown',
        'microcode': 'Unknown',
        'flags': [],
        'cpu_family': 'Unknown',
        'model': 'Unknown',
        'stepping': 'Unknown',
    }

    try:
        with open('/proc/cpuinfo', 'r') as f:
            content = f.read()

        # Parse first CPU entry (all CPUs typically have same model)
        for line in content.split('\n'):
            if ':' not in line:
                continue

            key, value = line.split(':', 1)
            key = key.strip().lower()
            value = value.strip()

            if key == 'vendor_id':
                cpu_info['vendor'] = value
            elif key == 'model name':
                cpu_info['model_name'] = value
            elif key == 'microcode':
                cpu_info['microcode'] = value
            elif key == 'cpu family':
                cpu_info['cpu_family'] = value
            elif key == 'model':
                cpu_info['model'] = value
            elif key == 'stepping':
                cpu_info['stepping'] = value
            elif key == 'flags':
                cpu_info['flags'] = value.split()
                break  # Got all we need from first CPU

    except FileNotFoundError:
        pass
    except Exception as e:
        print(f"Warning: Could not read /proc/cpuinfo: {e}", file=sys.stderr)

    return cpu_info


def get_kernel_cmdline():
    """Get kernel command-line parameters.

    Returns:
        str: Kernel command-line parameters
    """
    try:
        with open('/proc/cmdline', 'r') as f:
            return f.read().strip()
    except FileNotFoundError:
        return ""
    except Exception:
        return ""


def get_vulnerability_status():
    """Read vulnerability status from /sys/devices/system/cpu/vulnerabilities/.

    Returns:
        dict: Vulnerability name -> status mapping
    """
    vuln_dir = '/sys/devices/system/cpu/vulnerabilities'
    vulnerabilities = {}

    if not os.path.isdir(vuln_dir):
        return vulnerabilities

    try:
        for vuln_name in os.listdir(vuln_dir):
            vuln_path = os.path.join(vuln_dir, vuln_name)
            if os.path.isfile(vuln_path):
                try:
                    with open(vuln_path, 'r') as f:
                        vulnerabilities[vuln_name] = f.read().strip()
                except Exception:
                    vulnerabilities[vuln_name] = 'Unknown (read error)'
    except Exception as e:
        print(f"Warning: Could not read vulnerability directory: {e}",
              file=sys.stderr)

    return vulnerabilities


def analyze_vulnerability(name, status):
    """Analyze a single vulnerability status.

    Args:
        name: Vulnerability name
        status: Status string from kernel

    Returns:
        dict: Analysis result with severity and details
    """
    result = {
        'name': name,
        'status': status,
        'mitigated': False,
        'severity': 'UNKNOWN',
        'details': '',
    }

    # Check if mitigated
    for pattern in MITIGATED_PATTERNS:
        if status.startswith(pattern):
            result['mitigated'] = True
            result['severity'] = 'OK'
            result['details'] = 'Mitigation active'
            break

    # Check if explicitly vulnerable
    if not result['mitigated']:
        for pattern in VULNERABLE_PATTERNS:
            if pattern in status:
                result['severity'] = 'CRITICAL'
                result['details'] = 'System is vulnerable - mitigation disabled or unavailable'
                break

    # Handle unknown status
    if result['severity'] == 'UNKNOWN':
        result['severity'] = 'WARNING'
        result['details'] = 'Unable to determine mitigation status'

    return result


def check_mitigation_disabled_cmdline(cmdline):
    """Check if mitigations are disabled via kernel command line.

    Args:
        cmdline: Kernel command-line string

    Returns:
        list: List of disabled mitigations found
    """
    disabled = []

    # Check for global mitigation disable
    if 'mitigations=off' in cmdline:
        disabled.append('All mitigations disabled via mitigations=off')

    # Check for specific disables
    disable_patterns = [
        ('nospectre_v1', 'Spectre v1 mitigation disabled'),
        ('nospectre_v2', 'Spectre v2 mitigation disabled'),
        ('nopti', 'Page Table Isolation (Meltdown mitigation) disabled'),
        ('nospec_store_bypass_disable', 'Speculative Store Bypass mitigation disabled'),
        ('no_stf_barrier', 'Store Forwarding Barrier disabled'),
        ('tsx=on', 'TSX enabled (potential TAA vulnerability)'),
        ('mds=off', 'MDS mitigation disabled'),
        ('l1tf=off', 'L1TF mitigation disabled'),
        ('srbds=off', 'SRBDS mitigation disabled'),
    ]

    for pattern, message in disable_patterns:
        if pattern in cmdline:
            disabled.append(message)

    return disabled


def analyze_all_vulnerabilities(vulnerabilities, cmdline):
    """Analyze all vulnerabilities and generate report.

    Args:
        vulnerabilities: Dict of vulnerability statuses
        cmdline: Kernel command-line

    Returns:
        tuple: (list of results, list of issues)
    """
    results = []
    issues = []

    # Analyze each vulnerability
    for name, status in sorted(vulnerabilities.items()):
        result = analyze_vulnerability(name, status)
        results.append(result)

        if result['severity'] == 'CRITICAL':
            issues.append({
                'severity': 'CRITICAL',
                'vulnerability': name,
                'message': f'{name}: {result["details"]}',
                'status': status,
            })
        elif result['severity'] == 'WARNING':
            issues.append({
                'severity': 'WARNING',
                'vulnerability': name,
                'message': f'{name}: {result["details"]}',
                'status': status,
            })

    # Check for cmdline disables
    disabled = check_mitigation_disabled_cmdline(cmdline)
    for msg in disabled:
        issues.append({
            'severity': 'CRITICAL',
            'vulnerability': 'cmdline',
            'message': msg,
            'status': 'Disabled via kernel parameter',
        })

    return results, issues


def output_plain(cpu_info, vulnerabilities, results, issues, verbose, warn_only):
    """Output in plain text format."""
    if not warn_only:
        print(f"CPU: {cpu_info['model_name']}")
        print(f"Vendor: {cpu_info['vendor']}")
        print(f"Microcode: {cpu_info['microcode']}")
        print()

        print("Vulnerability Status:")
        for result in results:
            status_char = '+' if result['mitigated'] else '-'
            print(f"  [{status_char}] {result['name']}: {result['status']}")

        if verbose:
            print()
            print(f"CPU Family: {cpu_info['cpu_family']}")
            print(f"Model: {cpu_info['model']}")
            print(f"Stepping: {cpu_info['stepping']}")

    if issues:
        if not warn_only:
            print()
            print("=" * 60)
            print("ISSUES DETECTED")
            print("=" * 60)

        for issue in issues:
            print(f"[{issue['severity']}] {issue['message']}")

    if not issues and not warn_only:
        print()
        print("All mitigations active. No vulnerabilities exposed.")


def output_json(cpu_info, vulnerabilities, results, issues):
    """Output in JSON format."""
    critical_count = sum(1 for i in issues if i['severity'] == 'CRITICAL')
    warning_count = sum(1 for i in issues if i['severity'] == 'WARNING')

    output = {
        'cpu': {
            'vendor': cpu_info['vendor'],
            'model_name': cpu_info['model_name'],
            'microcode': cpu_info['microcode'],
            'cpu_family': cpu_info['cpu_family'],
            'model': cpu_info['model'],
            'stepping': cpu_info['stepping'],
        },
        'vulnerabilities': vulnerabilities,
        'analysis': results,
        'issues': issues,
        'summary': {
            'total_vulnerabilities': len(vulnerabilities),
            'mitigated': sum(1 for r in results if r['mitigated']),
            'not_mitigated': sum(1 for r in results if not r['mitigated']),
            'critical_issues': critical_count,
            'warning_issues': warning_count,
        }
    }

    print(json.dumps(output, indent=2))


def output_table(cpu_info, vulnerabilities, results, issues, verbose, warn_only):
    """Output in table format."""
    if not warn_only:
        print("=" * 70)
        print(f"{'CPU VULNERABILITY SCAN':^70}")
        print("=" * 70)
        print()

        print(f"{'Property':<20} {'Value':<50}")
        print("-" * 70)
        print(f"{'CPU Model':<20} {cpu_info['model_name'][:50]:<50}")
        print(f"{'Vendor':<20} {cpu_info['vendor']:<50}")
        print(f"{'Microcode':<20} {cpu_info['microcode']:<50}")

        if verbose:
            print(f"{'CPU Family':<20} {cpu_info['cpu_family']:<50}")
            print(f"{'Model':<20} {cpu_info['model']:<50}")
            print(f"{'Stepping':<20} {cpu_info['stepping']:<50}")

        print()
        print("=" * 70)
        print(f"{'VULNERABILITY STATUS':^70}")
        print("=" * 70)
        print()

        print(f"{'Vulnerability':<25} {'Status':<8} {'Details':<35}")
        print("-" * 70)

        for result in results:
            status = 'OK' if result['mitigated'] else 'VULN'
            details = result['status'][:35]
            print(f"{result['name']:<25} {status:<8} {details:<35}")

        print()

    if issues:
        if not warn_only:
            print("=" * 70)
            print(f"{'ISSUES DETECTED':^70}")
            print("=" * 70)
            print()

        print(f"{'Severity':<12} {'Issue':<58}")
        print("-" * 70)

        for issue in issues:
            msg = issue['message'][:58]
            print(f"{issue['severity']:<12} {msg:<58}")

        print()

    if not issues and not warn_only:
        print("=" * 70)
        print(f"{'ALL MITIGATIONS ACTIVE':^70}")
        print("=" * 70)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Scan CPU vulnerabilities and mitigation status',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        '--format',
        choices=['plain', 'json', 'table'],
        default='plain',
        help='Output format (default: %(default)s)'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Show detailed CPU information'
    )

    parser.add_argument(
        '-w', '--warn-only',
        action='store_true',
        help='Only show warnings and issues (suppress normal output)'
    )

    args = parser.parse_args()

    # Check for vulnerability directory
    vuln_dir = '/sys/devices/system/cpu/vulnerabilities'
    if not os.path.isdir(vuln_dir):
        print(f"Error: {vuln_dir} not found", file=sys.stderr)
        print("This system may not expose CPU vulnerability information.",
              file=sys.stderr)
        print("Requires Linux kernel 4.14+ with vulnerability reporting.",
              file=sys.stderr)
        sys.exit(2)

    # Gather information
    cpu_info = get_cpu_info()
    cmdline = get_kernel_cmdline()
    vulnerabilities = get_vulnerability_status()

    if not vulnerabilities:
        print("Error: No vulnerability information available", file=sys.stderr)
        sys.exit(2)

    # Analyze
    results, issues = analyze_all_vulnerabilities(vulnerabilities, cmdline)

    # Output
    if args.format == 'json':
        output_json(cpu_info, vulnerabilities, results, issues)
    elif args.format == 'table':
        output_table(cpu_info, vulnerabilities, results, issues,
                     args.verbose, args.warn_only)
    else:
        output_plain(cpu_info, vulnerabilities, results, issues,
                     args.verbose, args.warn_only)

    # Exit code based on issues
    critical_issues = any(i['severity'] == 'CRITICAL' for i in issues)
    if critical_issues or issues:
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    main()

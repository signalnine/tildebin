#!/usr/bin/env python3
# boxctl:
#   category: baremetal/security
#   tags: [security, cpu, vulnerability, spectre, meltdown]
#   requires: []
#   privilege: user
#   related: [firmware_security, kernel_cmdline_audit]
#   brief: Scan CPU vulnerabilities and kernel mitigation status

"""
Scan CPU hardware vulnerabilities and kernel mitigation status.

Checks for CPU security vulnerabilities (Spectre, Meltdown, and variants)
and verifies kernel mitigations are enabled. Critical for security compliance
in large-scale baremetal deployments.

Reads from:
- /sys/devices/system/cpu/vulnerabilities/ for kernel mitigation status
- /proc/cpuinfo for CPU model and flags
- /proc/cmdline for kernel parameters affecting mitigations

Returns exit code 1 if vulnerabilities are detected or mitigations not enabled.
"""

import argparse
import re
from typing import Any

from boxctl.core.context import Context
from boxctl.core.output import Output


# Status strings indicating vulnerability is mitigated
MITIGATED_PATTERNS = [
    'Mitigation:',
    'Not affected',
    'KVM: Mitigation:',
]

# Status strings indicating vulnerability is NOT mitigated
VULNERABLE_PATTERNS = [
    'Vulnerable',
    'Vulnerable:',
]

# Kernel cmdline patterns that disable mitigations
DISABLE_PATTERNS = [
    ('mitigations=off', 'All mitigations disabled via mitigations=off'),
    ('nospectre_v1', 'Spectre v1 mitigation disabled'),
    ('nospectre_v2', 'Spectre v2 mitigation disabled'),
    ('nopti', 'Page Table Isolation (Meltdown mitigation) disabled'),
    ('nospec_store_bypass_disable', 'Speculative Store Bypass mitigation disabled'),
    ('no_stf_barrier', 'Store Forwarding Barrier disabled'),
    ('tsx=on', 'TSX enabled (potential TAA vulnerability)'),
    ('mds=off', 'MDS mitigation disabled'),
    ('l1tf=off', 'L1TF mitigation disabled'),
    ('srbds=off', 'SRBDS mitigation disabled'),
]


def get_cpu_info(context: Context) -> dict[str, Any]:
    """Get CPU model and flags from /proc/cpuinfo."""
    cpu_info = {
        'vendor': 'Unknown',
        'model_name': 'Unknown',
        'microcode': 'Unknown',
        'cpu_family': 'Unknown',
        'model': 'Unknown',
        'stepping': 'Unknown',
    }

    if not context.file_exists('/proc/cpuinfo'):
        return cpu_info

    try:
        content = context.read_file('/proc/cpuinfo')
        for line in content.split('\n'):
            if ':' not in line:
                continue

            key, value = line.split(':', 1)
            key = key.strip().lower()
            value = value.strip()

            if key == 'vendor_id':
                cpu_info['vendor'] = value
            elif key == 'model name':
                cpu_info['model_name'] = value
            elif key == 'microcode':
                cpu_info['microcode'] = value
            elif key == 'cpu family':
                cpu_info['cpu_family'] = value
            elif key == 'model':
                cpu_info['model'] = value
            elif key == 'stepping':
                cpu_info['stepping'] = value
                break  # Got all we need from first CPU
    except Exception:
        pass

    return cpu_info


def get_kernel_cmdline(context: Context) -> str:
    """Get kernel command-line parameters."""
    if not context.file_exists('/proc/cmdline'):
        return ""
    try:
        return context.read_file('/proc/cmdline')
    except Exception:
        return ""


def get_vulnerability_status(context: Context) -> dict[str, str]:
    """Read vulnerability status from /sys/devices/system/cpu/vulnerabilities/."""
    vuln_dir = '/sys/devices/system/cpu/vulnerabilities'
    vulnerabilities = {}

    # Use glob to find vulnerability files
    vuln_files = context.glob('*', vuln_dir)

    for vuln_path in vuln_files:
        vuln_name = vuln_path.split('/')[-1]
        try:
            status = context.read_file(vuln_path)
            vulnerabilities[vuln_name] = status.strip()
        except Exception:
            vulnerabilities[vuln_name] = 'Unknown (read error)'

    return vulnerabilities


def analyze_vulnerability(name: str, status: str) -> dict[str, Any]:
    """Analyze a single vulnerability status."""
    result = {
        'name': name,
        'status': status,
        'mitigated': False,
        'severity': 'UNKNOWN',
    }

    # Check if mitigated
    for pattern in MITIGATED_PATTERNS:
        if status.startswith(pattern):
            result['mitigated'] = True
            result['severity'] = 'OK'
            break

    # Check if explicitly vulnerable
    if not result['mitigated']:
        for pattern in VULNERABLE_PATTERNS:
            if pattern in status:
                result['severity'] = 'CRITICAL'
                break

    # Handle unknown status
    if result['severity'] == 'UNKNOWN':
        result['severity'] = 'WARNING'

    return result


def check_cmdline_disables(cmdline: str) -> list[dict[str, str]]:
    """Check if mitigations are disabled via kernel command line."""
    issues = []

    for pattern, message in DISABLE_PATTERNS:
        if pattern in cmdline:
            issues.append({
                'pattern': pattern,
                'message': message,
                'severity': 'CRITICAL',
            })

    return issues


def run(args: list[str], output: Output, context: Context) -> int:
    """
    Main entry point.

    Args:
        args: Command-line arguments
        output: Output helper
        context: Execution context

    Returns:
        0 = all mitigated, 1 = issues found, 2 = error
    """
    parser = argparse.ArgumentParser(description="Scan CPU vulnerabilities and mitigation status")
    parser.add_argument("-v", "--verbose", action="store_true", help="Show detailed output")
    parser.add_argument("--format", choices=["plain", "json"], default="plain")
    opts = parser.parse_args(args)

    # Check for vulnerability directory
    vuln_dir = '/sys/devices/system/cpu/vulnerabilities'
    if not context.file_exists(vuln_dir):
        output.error("CPU vulnerability interface not available")
        output.error("Requires Linux kernel 4.14+ with vulnerability reporting")
        return 2

    # Gather information
    cpu_info = get_cpu_info(context)
    cmdline = get_kernel_cmdline(context)
    vulnerabilities = get_vulnerability_status(context)

    if not vulnerabilities:
        output.error("No vulnerability information available")
        return 2

    # Analyze each vulnerability
    results = []
    has_issues = False

    for name, status in sorted(vulnerabilities.items()):
        result = analyze_vulnerability(name, status)
        results.append(result)

        if result['severity'] in ('CRITICAL', 'WARNING'):
            has_issues = True

    # Check for cmdline disables
    cmdline_issues = check_cmdline_disables(cmdline)
    if cmdline_issues:
        has_issues = True

    # Build output data
    data = {
        'cpu': {
            'vendor': cpu_info['vendor'],
            'model_name': cpu_info['model_name'],
            'microcode': cpu_info['microcode'],
        },
        'vulnerabilities': results,
        'cmdline_issues': cmdline_issues,
    }

    if opts.verbose:
        data['cpu']['cpu_family'] = cpu_info['cpu_family']
        data['cpu']['model'] = cpu_info['model']
        data['cpu']['stepping'] = cpu_info['stepping']

    output.emit(data)

    # Generate summary
    mitigated = sum(1 for r in results if r['mitigated'])
    total = len(results)
    critical = sum(1 for r in results if r['severity'] == 'CRITICAL')
    critical += len(cmdline_issues)

    if critical > 0:
        output.set_summary(f"{critical} critical issues, {mitigated}/{total} mitigated")
    else:
        output.set_summary(f"{mitigated}/{total} mitigated")

    return 1 if has_issues else 0


if __name__ == "__main__":
    import sys
    sys.exit(run(sys.argv[1:], Output(), Context()))
